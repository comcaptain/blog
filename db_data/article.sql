/*
Navicat MySQL Data Transfer

Source Server         : pygmalion
Source Server Version : 50621
Source Host           : localhost:3306
Source Database       : pygmalion

Target Server Type    : MYSQL
Target Server Version : 50621
File Encoding         : 65001

Date: 2015-03-17 20:16:16
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL,
  `content` mediumtext,
  `markdown` mediumtext,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `author` int(11) DEFAULT NULL,
  `thumbnail` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`article_id`),
  KEY `fk_article_user_idx` (`author`),
  CONSTRAINT `fk_article_user` FOREIGN KEY (`author`) REFERENCES `user` (`user_id`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', 'To do list', '<ol>\n<li>move my cmd here, and the url is <a href=\"./cmd\">/Pygmalion/cmd</a></li>\n</ol>\n', '1. move my cmd here, and the url is [/Pygmalion/cmd](./cmd)', '2015-03-05 15:40:26', '2015-03-16 09:45:25', '1', 'move my cmd here, and the url is /Pygmalion/cmd');
INSERT INTO `article` VALUES ('2', '路由器弱口令入侵', '<p>  为了防止被蹭网，现在大多数人都会给自家的wifi设置一个强密码，但是很少有人会去修改自己的路由器管理密码，大多依旧是默认的admin@admin。</p>\n<p>  因为照常理来说，不知道wifi密码就连不到路由器所在的局域网，也就无法登陆路由器。但是，很多路由器的web管理页面做的很差，login用的是<a href=\"http://www.wikiwand.com/en/Basic_access_authentication\">HTTP Basic authentication (BA)</a>，提交表单用的是GET请求，这就导致访问一个url就有可能改变你的路由器设置。 基于这个思路，下面介绍了利用路由器弱口令进行dns劫持，进而进行中间人攻击。</p>\n<p>基本思路：</p>\n<ol>\n<li><p>dns劫持, 在可以插入外链图片的网站中插入外链图片, 对同一个用户</p>\n<ul>\n<li><p>第1次请求跳转到<a href=\"http://admin:admin@192.168.1.1/userRpm/PPPoECfgAdvRpm.htm?wan=0&amp;lcpMru=1480&amp;ServiceName=&amp;AcName=&amp;EchoReq=0&amp;manual=2&amp;dnsserver=黑客服务器&amp;dnsserver2=8.8.8.8&amp;downBandwidth=0&amp;upBandwidth=0&amp;Save=%B1%A3+%B4%E6&amp;Advanced=Advanced\">http://admin:admin@192.168.1.1/userRpm/PPPoECfgAdvRpm.htm?wan=0&amp;lcpMru=1480&amp;ServiceName=&amp;AcName=&amp;EchoReq=0&amp;manual=2&amp;dnsserver=黑客服务器&amp;dnsserver2=8.8.8.8&amp;downBandwidth=0&amp;upBandwidth=0&amp;Save=%B1%A3+%B4%E6&amp;Advanced=Advanced</a></p></li>\n<li><p>第2,3次请求显示真正的图片。可以通过cookie来标识用户</p></li>\n</ul></li>\n<li><p>流量劫持。</p>\n<ul>\n<li>建立dns服务器，将目标网站的域名解析到我的http代理服务器，其它域名解析代理到8.8.8.8(<a href=\"https://github.com/tjfontaine/node-dns\">node-dns</a>)</li>\n<li>代理服务器可以用<a href=\"http://mitmproxy.org/\">mitmproxy</a>，这个可以实时替换流量中的任何文件</li>\n<li>如果目标网站是明文提交，设定正则表达式拉取用户名密码，如果header中cookie的sessionId部分的过期时间长，就拉取cookie</li>\n</ul></li>\n<li><p>缓存投毒。</p>\n<ul>\n<li><p>找到目标网站一个过期时间设置的很长的js文件，在其中加入以下js代码，然后将header中的expire时间设置的非常长，还有last-modified字段设置成很多年以后，然后干掉cache-control</p>\n<ul>\n<li>在form的submit中添加submit的listener，取得之后拦截submit请求，取得用户名和密码，然后添加一个隐藏的图片将用户名和密码发送到密码服务器，为了保证能传到服务器，延时一秒后再提交表单</li>\n<li>取得自动填写的表单，在load的时候取得表单的内容， 如果有值就发送到密码服务器</li>\n<li>（定期执行，在cookie中做标记看是否执行过）检测浏览器，如果浏览器支持iframe表单自动填写，就添加隐藏的iframe，iframe指向目标网站，但是假如特定的query字符串，在proxy中匹配这个字符串，当存在的时候将页面替换成一个简单的form表单页面（表单中的name和目标网站的一致）</li>\n</ul></li>\n<li><p>触发缓存</p>\n<ul>\n<li>实时在html中添加隐藏的iframe，隐藏的iframe指向目标网站，html标签加上manifest属性（离线缓存）</li>\n<li>访问遭到修改的js地址</li>\n</ul></li>\n</ul></li>\n</ol>\n', '&emsp;&emsp;为了防止被蹭网，现在大多数人都会给自家的wifi设置一个强密码，但是很少有人会去修改自己的路由器管理密码，大多依旧是默认的admin@admin。  \n\n&emsp;&emsp;因为照常理来说，不知道wifi密码就连不到路由器所在的局域网，也就无法登陆路由器。但是，很多路由器的web管理页面做的很差，login用的是[HTTP Basic authentication (BA)](http://www.wikiwand.com/en/Basic_access_authentication)，提交表单用的是GET请求，这就导致访问一个url就有可能改变你的路由器设置。 基于这个思路，下面介绍了利用路由器弱口令进行dns劫持，进而进行中间人攻击。\n\n基本思路：\n\n1. dns劫持, 在可以插入外链图片的网站中插入外链图片, 对同一个用户\n    * 第1次请求跳转到<http://admin:admin@192.168.1.1/userRpm/PPPoECfgAdvRpm.htm?wan=0&lcpMru=1480&ServiceName=&AcName=&EchoReq=0&manual=2&dnsserver=黑客服务器&dnsserver2=8.8.8.8&downBandwidth=0&upBandwidth=0&Save=%B1%A3+%B4%E6&Advanced=Advanced>  \n\n     * 第2,3次请求显示真正的图片。可以通过cookie来标识用户\n\n2. 流量劫持。\n\n	* 建立dns服务器，将目标网站的域名解析到我的http代理服务器，其它域名解析代理到8.8.8.8([node-dns](https://github.com/tjfontaine/node-dns))\n	* 代理服务器可以用[mitmproxy](http://mitmproxy.org/)，这个可以实时替换流量中的任何文件\n	* 如果目标网站是明文提交，设定正则表达式拉取用户名密码，如果header中cookie的sessionId部分的过期时间长，就拉取cookie\n\n3. 缓存投毒。\n\n	* 找到目标网站一个过期时间设置的很长的js文件，在其中加入以下js代码，然后将header中的expire时间设置的非常长，还有last-modified字段设置成很多年以后，然后干掉cache-control\n		* 在form的submit中添加submit的listener，取得之后拦截submit请求，取得用户名和密码，然后添加一个隐藏的图片将用户名和密码发送到密码服务器，为了保证能传到服务器，延时一秒后再提交表单\n		* 取得自动填写的表单，在load的时候取得表单的内容， 如果有值就发送到密码服务器\n		* （定期执行，在cookie中做标记看是否执行过）检测浏览器，如果浏览器支持iframe表单自动填写，就添加隐藏的iframe，iframe指向目标网站，但是假如特定的query字符串，在proxy中匹配这个字符串，当存在的时候将页面替换成一个简单的form表单页面（表单中的name和目标网站的一致）\n\n	* 触发缓存\n		* 实时在html中添加隐藏的iframe，隐藏的iframe指向目标网站，html标签加上manifest属性（离线缓存）\n		* 访问遭到修改的js地址\n\n\n', '2014-10-07 16:27:37', '2014-10-14 18:07:44', '1', '  为了防止被蹭网，现在大多数人都会给自家的wifi设置一个强密码，但是很少有人会去修改自己的路由器管理密码，大多依旧是默认的admin@admin。');
INSERT INTO `article` VALUES ('5', 'Struts2 and Spring integration thread safe', '<p>If you are using Struts2-Spring plugin make sure to put bean scope as prototype.</p>\n<p>Struts2 create new instance of action on each request, since action work as a model also and in order to make it thread safe a new object is being created on each request and placed on value stack.</p>\n<p>Not proving scope will be treated by Spring as singleton and for ever request same action instance will be given back which can leads to a lot of issue from data corruption to weird behavior.</p>\n', 'If you are using Struts2-Spring plugin make sure to put bean scope as prototype.\n\nStruts2 create new instance of action on each request, since action work as a model also and in order to make it thread safe a new object is being created on each request and placed on value stack.\n\nNot proving scope will be treated by Spring as singleton and for ever request same action instance will be given back which can leads to a lot of issue from data corruption to weird behavior.', '2014-10-09 14:19:48', '2014-10-14 18:07:38', '1', 'If you are using Struts2-Spring plugin make sure to put bean scope as prototype.');
INSERT INTO `article` VALUES ('7', 'PushState: what exactly is the state object for', '<p>HTML5 has extended <code>window.history</code> and now we can modify url without reload(of course, considering security, you can only change to a url in the same domain)</p>\n<p>Take this small example: <a href=\"http://jsfiddle.net/janfoeh/2SCbv/show/light/\">run fiddle</a> (<a href=\"http://jsfiddle.net/janfoeh/2SCbv\">editor view</a>):</p>\n<p>You have a page where a user can select a color. Every time they do, we generate a new history entry:</p>\n<pre><code>function doPushState(color) {\n    var state = {},\n        title = \"Page title\",\n        path  = \"/\" + color;\n    \n    history.pushState(state, title, path);\n};\n</code></pre>\n<p>We leave the state object blank for now and set the URL to the color name (don\'t reload the page - that URL doesn\'t exist, so you will get a 404).</p>\n<p>Now click on a red, green and blue once each. Note that the URL changes. Now what happens if you click the back button?</p>\n<p>The browser does indeed go back in history, but our page doesn\'t notice that - the URL changes from \'/blue\' back to \'/green\', but our page stays at \'You have selected blue\'. Our page has gone out of sync with the URL.</p>\n<p>This is what the <code>window.onpopstate</code> event and the state object are for:</p>\n<ol>\n<li><p>we include our selected color in our state object</p>\n<pre><code> function doPushState(color) {\n     var state = { selectedColor: color },\n         title = \"Page title\",\n         path  = \"/\" + color;\n \n     history.pushState(state, title, path);\n };\n</code></pre></li>\n<li><p>then we listen for the <code>popstate</code> event, so that we know when we have to update the selected color:</p>\n<pre><code> $(window).on(\'popstate\', function(event) {\n     var state = event.originalEvent.state;\n \n     if (state) {\n         selectColor( state.selectedColor );\n     }\n });\n</code></pre></li>\n</ol>\n<p>Try the updated example: <a href=\"http://jsfiddle.net/janfoeh/2SCbv/11/show/light/\">run fiddle</a> (<a href=\"http://jsfiddle.net/janfoeh/2SCbv/11\">editor view</a>): our page now updates accordingly when the user navigates back through history.</p>\n', 'HTML5 has extended `window.history` and now we can modify url without reload(of course, considering security, you can only change to a url in the same domain) \n\nTake this small example: [run fiddle][1] ([editor view][2]):\n\nYou have a page where a user can select a color. Every time they do, we generate a new history entry:\n\n    function doPushState(color) {\n        var state = {},\n            title = \"Page title\",\n            path  = \"/\" + color;\n        \n        history.pushState(state, title, path);\n    };\n\nWe leave the state object blank for now and set the URL to the color name (don\'t reload the page - that URL doesn\'t exist, so you will get a 404).\n\nNow click on a red, green and blue once each. Note that the URL changes. Now what happens if you click the back button?\n\nThe browser does indeed go back in history, but our page doesn\'t notice that - the URL changes from \'/blue\' back to \'/green\', but our page stays at \'You have selected blue\'. Our page has gone out of sync with the URL.\n\nThis is what the `window.onpopstate` event and the state object are for:\n\n1. we include our selected color in our state object\n\n        function doPushState(color) {\n            var state = { selectedColor: color },\n                title = \"Page title\",\n                path  = \"/\" + color;\n        \n            history.pushState(state, title, path);\n        };\n\n2. then we listen for the `popstate` event, so that we know when we have to update the selected color:\n\n        $(window).on(\'popstate\', function(event) {\n            var state = event.originalEvent.state;\n        \n            if (state) {\n                selectColor( state.selectedColor );\n            }\n        });\n\nTry the updated example: [run fiddle][3] ([editor view][4]): our page now updates accordingly when the user navigates back through history.\n\n  [1]: http://jsfiddle.net/janfoeh/2SCbv/show/light/\n  [2]: http://jsfiddle.net/janfoeh/2SCbv\n  [3]: http://jsfiddle.net/janfoeh/2SCbv/11/show/light/\n  [4]: http://jsfiddle.net/janfoeh/2SCbv/11', '2014-10-09 14:34:33', '2014-10-14 18:07:31', '1', 'HTML5 has extended window.history and now we can modify url without reload(of course, considering security, you can only change to a url in the same domain)');
INSERT INTO `article` VALUES ('11', 'to do list', '<p>下面是本网站待开发的feature列表：</p>\n<ol>\n<li>编辑器功能\n<ul>\n<li><del>ctrl + b: bold</del></li>\n<li><del>ctrl + shift + b: blockquote</del></li>\n<li><del>ctrl + k: wrap code</del></li>\n<li><del>ctrl + d: delete selected lines</del></li>\n<li><del>ctrl + shift + d: wrap selected text with &lt;del&gt; tag</del></li>\n</ul></li>\n<li>用户login，不开放注册\n<ul>\n<li><del>按ctrl shift l(ogin)弹出login窗口</del></li>\n<li><del>ctrl q，退出login</del></li>\n</ul></li>\n<li>权限控制\n<ul>\n<li><del>在interceptor中实现login控制，需要login之后才能进入的加上annotaion，在interceptor中统一处理</del></li>\n<li><del>用role based做权限管理，在login的时候读入privilege信息</del></li>\n</ul></li>\n<li>thumbnail服务器端生成算法</li>\n<li>html注入过滤</li>\n<li>全局快捷键\n<ul>\n<li>ctrl + shift + h: home</li>\n<li>ctrl + shift + n: new article</li>\n<li>ctrl + e: edit</li>\n<li>ctrl + shift + d: delete article</li>\n</ul></li>\n<li>工具页面，全局快捷键是ctrl + shift + t(ool)，下面是集成的工具列表\n<ul>\n<li>颜色转换 rgb 和hex</li>\n<li>keycode查询</li>\n<li>javascript format</li>\n</ul></li>\n</ol>\n', '下面是本网站待开发的feature列表：\n\n1. 编辑器功能\n    * <del>ctrl + b: bold</del>\n    * <del>ctrl + shift + b: blockquote</del>\n    * <del>ctrl + k: wrap code</del>\n    * <del>ctrl + d: delete selected lines</del>\n    * <del>ctrl + shift + d: wrap selected text with \\<del\\> tag</del>\n2. 用户login，不开放注册\n    * <del>按ctrl shift l(ogin)弹出login窗口</del>\n    * <del>ctrl q，退出login</del>\n3. 权限控制\n    * <del>在interceptor中实现login控制，需要login之后才能进入的加上annotaion，在interceptor中统一处理</del>\n    * <del>用role based做权限管理，在login的时候读入privilege信息</del>\n4. thumbnail服务器端生成算法\n5. html注入过滤\n6. 全局快捷键\n   * ctrl + shift + h: home\n   * ctrl + shift + n: new article\n   * ctrl + e: edit\n   * ctrl + shift + d: delete article \n7. 工具页面，全局快捷键是ctrl + shift + t(ool)，下面是集成的工具列表\n   * 颜色转换 rgb 和hex\n   * keycode查询\n   * javascript format', '2014-10-10 11:14:10', '2014-11-17 10:39:33', '1', '下面是本网站待开发的feature列表：');
INSERT INTO `article` VALUES ('13', '未来的新版块计划', '<p>本网站未来可能会实现的新的板块列表：</p>\n<ol>\n<li>翻译板块<br>\n功能仿照oschina的翻译模块，但是不开放翻译的编辑权限，下面是一些不成系统的想法：\n<ul>\n<li>文章导入实现自动化，html导入成Markdown参考<a href=\"https://github.com/domchristie/to-markdown\">这个</a></li>\n<li>中英文对照</li>\n<li>翻译编辑功能，右边使用markdown   abc</li>\n</ul></li>\n</ol>\n', '本网站未来可能会实现的新的板块列表：\n\n1. 翻译板块  \n    功能仿照oschina的翻译模块，但是不开放翻译的编辑权限，下面是一些不成系统的想法：\n   - 文章导入实现自动化，html导入成Markdown参考[这个](https://github.com/domchristie/to-markdown)\n   - 中英文对照\n   - 翻译编辑功能，右边使用markdown   abc', '2014-10-15 13:04:14', '2014-11-14 16:48:29', '1', '本网站未来可能会实现的新的板块列表：');
INSERT INTO `article` VALUES ('15', 'db分离', '<p><strong>分离方案</strong></p>\n<ol>\n<li>建立固化view\n<ul>\n<li>坏处：占据的空间double</li>\n</ul></li>\n<li>使用基本的view\n<ul>\n<li>坏处：查询效率低</li>\n</ul></li>\n<li>完全不使用view\n<ul>\n<li>实现：查询两次，然后将结果merge，效率比2好，比1差</li>\n<li>不能用的原因：merge在分页的时候不能实现，原因是：比如200-300取出来，只能把新旧表的所有数据都拿出来再排序，这会导致内存溢出，新表的200-300和旧表的200-300的merge结果并不是总结果的200-300\n<br><br></li>\n</ul></li>\n<li>partition 方案</li>\n</ol>\n<p><strong>固化view方案的实现</strong></p>\n<ol>\n<li>查询（业务层面的查询）\n<ul>\n<li>实现方式：两种不同的查询方式（只查新表以及新旧表一起查），对应不同的表名</li>\n<li>影响范围：综合检索，4个集计</li>\n</ul></li>\n<li>更新\n<ul>\n<li>实现方式：所有的model中加入是否是新表的flg字段</li>\n<li>影响范围：service层所有的查询（加入flg字段）和更新（根据flg来判断用哪个表去查）</li>\n</ul></li>\n<li>插入\n<ul>\n<li>实现方式：接口上加一个参数（新表flg），来决定插入哪个表</li>\n<li>影响范围：牵涉到db分离表的所有插入（保留原有的接口，大部分都是插入新表，所有原有接口默认插入新表），插入旧表只有子表这一种情况</li>\n</ul></li>\n</ol>\n<p><strong>固化view方案的实现（业务角度）</strong></p>\n<ol>\n<li>数据更新的入口\n<ul>\n<li>batch，从db中查询结果然后执行</li>\n<li>综合检索和3个集计的检索结果通知list，然后进入障害和問い合わせ画面更新</li>\n<li>api，从db中查询结果然后执行</li>\n<li>一括status变更</li>\n</ul></li>\n</ol>\n<p><strong>partition 方案</strong></p>\n<ol>\n<li><strong>想法</strong>：根据mod_date分离trouble表，以to_timestamp来分离，在partition上建立全套的local index</li>\n<li><strong>效果测试</strong>：目的为测试和修改日期组合之后，检索效率提升。新partition数量级为十万级</li>\n</ol>\n', '**分离方案**\n\n\n1. 建立固化view\n   * 坏处：占据的空间double\n2. 使用基本的view\n   * 坏处：查询效率低\n3. 完全不使用view\n   * 实现：查询两次，然后将结果merge，效率比2好，比1差\n   * 不能用的原因：merge在分页的时候不能实现，原因是：比如200-300取出来，只能把新旧表的所有数据都拿出来再排序，这会导致内存溢出，新表的200-300和旧表的200-300的merge结果并不是总结果的200-300\n<br><br>\n4. partition 方案\n\n\n**固化view方案的实现**\n\n\n1. 查询（业务层面的查询）\n    * 实现方式：两种不同的查询方式（只查新表以及新旧表一起查），对应不同的表名\n    * 影响范围：综合检索，4个集计\n2. 更新\n    * 实现方式：所有的model中加入是否是新表的flg字段\n    * 影响范围：service层所有的查询（加入flg字段）和更新（根据flg来判断用哪个表去查）\n3. 插入\n    * 实现方式：接口上加一个参数（新表flg），来决定插入哪个表\n    * 影响范围：牵涉到db分离表的所有插入（保留原有的接口，大部分都是插入新表，所有原有接口默认插入新表），插入旧表只有子表这一种情况\n\n\n**固化view方案的实现（业务角度）**\n1. 数据更新的入口\n   * batch，从db中查询结果然后执行\n   * 综合检索和3个集计的检索结果通知list，然后进入障害和問い合わせ画面更新\n   * api，从db中查询结果然后执行\n   * 一括status变更\n\n**partition 方案**\n1. **想法**：根据mod_date分离trouble表，以to_timestamp来分离，在partition上建立全套的local index\n2. **效果测试**：目的为测试和修改日期组合之后，检索效率提升。新partition数量级为十万级\n\n\n\n\n\n\n\n\n\n\n\n\n', '2014-11-17 11:02:44', '2014-11-18 16:46:16', '1', '问题1，新老数据同时查询');
INSERT INTO `article` VALUES ('17', '背单词流程', '<ol>\n<li>login detection，如果没有login，就要先login</li>\n<li>选择词库</li>\n<li>拉取单词列表（和<code>word_memory_record</code>关联）\n<ul>\n<li>待复习单词列表，如果不为空，从待复习单词中抽出来20个\n<ul>\n<li>待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）</li>\n<li>抽取规则：nextReviewDate在&lt;=今天，level&gt;0</li>\n</ul></li>\n<li>未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个</li>\n</ul></li>\n<li>拉取今天的<code>word_memory_daily_statistics</code></li>\n<li>循环背单词（显示假名），并建立/更新每个单词的用户信息\n<ul>\n<li>pass_count</li>\n<li>fail_count</li>\n<li>not_sure_count</li>\n</ul></li>\n<li>快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量\n<ul>\n<li>level\n<ul>\n<li>0: 未背</li>\n<li>1: 已被标记为ok</li>\n<li>2: 在1天后复习</li>\n<li>3: 在2天后复习</li>\n<li>4: 在4天后复习</li>\n<li>5: 在7天后复习</li>\n<li>6: 在15天后复习</li>\n<li>7: 在30天后复习</li>\n</ul></li>\n<li>next_review_date</li>\n</ul></li>\n<li>将3,4中得到的用户信息和server同步，然后回到2</li>\n</ol>\n', '1. login detection，如果没有login，就要先login\n2. 选择词库\n3. 拉取单词列表（和`word_memory_record`关联）\n   - 待复习单词列表，如果不为空，从待复习单词中抽出来20个\n     - 待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）\n     - 抽取规则：nextReviewDate在<=今天，level>0\n   - 未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个\n4. 拉取今天的`word_memory_daily_statistics`\n5. 循环背单词（显示假名），并建立/更新每个单词的用户信息\n   - pass_count\n   - fail_count\n   - not_sure_count\n6. 快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量\n   - level\n     - 0: 未背\n     - 1: 已被标记为ok\n     - 2: 在1天后复习\n     - 3: 在2天后复习\n     - 4: 在4天后复习\n     - 5: 在7天后复习\n     - 6: 在15天后复习\n     - 7: 在30天后复习\n   - next_review_date\n7. 将3,4中得到的用户信息和server同步，然后回到2', '2015-03-05 16:04:39', '2015-03-16 09:45:14', '1', null);
INSERT INTO `article` VALUES ('18', '现有的console执行逻辑', '<h3>Command Part</h3>\n<ul>\n<li><strong>现有逻辑</strong>：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入</li>\n<li><strong>改造方法</strong>：Command的execute返回promise</li>\n</ul>\n<h3>Application Part</h3>\n<ul>\n<li><p><strong>现有逻辑</strong>：</p>\n<ul>\n<li><strong>启动application</strong>：\n<ol>\n<li>console调用start：<code>this.activeApplication = application;application.start(optionStr);</code></li>\n<li>application在start中调用main</li>\n</ol></li>\n<li><strong>进入输入模式/application命令行模式</strong>\n<ul>\n<li><strong>输入模式</strong>：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end</li>\n<li><strong>application命令行模式</strong>：将application的currentHandler置空，之后在console上注册applicationCommands</li>\n</ul></li>\n</ul></li>\n<li><p><strong>改造方法：</strong></p>\n<ul>\n<li>console作为控制主体，application的start和execute返回promise</li>\n<li>同时console提供getUserInput接口，该接口返回promise，这样可以让application主动获取用户输入，不用将控制权转回给console，从而可以去掉之前的<strong>输入模式</strong></li>\n</ul></li>\n</ul>\n', '### Command Part ###\n- **现有逻辑**：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入\n- **改造方法**：Command的execute返回promise\n\n### Application Part ###\n- **现有逻辑**：\n  - **启动application**：\n     1. console调用start：`this.activeApplication = application;application.start(optionStr);`\n     2. application在start中调用main\n  - **进入输入模式/application命令行模式**\n     - **输入模式**：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end\n     - **application命令行模式**：将application的currentHandler置空，之后在console上注册applicationCommands\n\n- **改造方法：**\n  - console作为控制主体，application的start和execute返回promise\n  - 同时console提供getUserInput接口，该接口返回promise，这样可以让application主动获取用户输入，不用将控制权转回给console，从而可以去掉之前的**输入模式**', '2015-03-06 15:25:45', '2015-03-16 09:47:56', '1', 'command part');
