article_id	title	content	markdown	create_time	update_time	author	thumbnail
1	To do list	<ol>\n<li>move my cmd here, and the url is <a href="./cmd">/Pygmalion/cmd</a></li>\n</ol>\n	1. move my cmd here, and the url is [/Pygmalion/cmd](./cmd)	2015/3/5 15:40:26	2015/3/5 15:40:26	1	move my cmd here, and the url is /Pygmalion/cmd
2	背单词流程	<ol>\n<li>login detection，如果没有login，就要先login</li>\n<li>选择词库</li>\n<li>拉取单词列表（和<code>word_memory_record</code>关联）\n<ul>\n<li>待复习单词列表，如果不为空，从待复习单词中抽出来20个\n<ul>\n<li>待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）</li>\n<li>抽取规则：nextReviewDate在&lt;=今天，level&gt;0</li>\n</ul></li>\n<li>未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个</li>\n</ul></li>\n<li>拉取今天的<code>word_memory_daily_statistics</code></li>\n<li>循环背单词（显示假名），并建立/更新每个单词的用户信息\n<ul>\n<li>pass_count</li>\n<li>fail_count</li>\n<li>not_sure_count</li>\n</ul></li>\n<li>快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量\n<ul>\n<li>level\n<ul>\n<li>0: 未背</li>\n<li>1: 已被标记为ok</li>\n<li>2: 在1天后复习</li>\n<li>3: 在2天后复习</li>\n<li>4: 在4天后复习</li>\n<li>5: 在7天后复习</li>\n<li>6: 在15天后复习</li>\n<li>7: 在30天后复习</li>\n</ul></li>\n<li>next_review_date</li>\n</ul></li>\n<li>将3,4中得到的用户信息和server同步，然后回到2</li>\n</ol>\n	1. login detection，如果没有login，就要先login\n2. 选择词库\n3. 拉取单词列表（和`word_memory_record`关联）\n   - 待复习单词列表，如果不为空，从待复习单词中抽出来20个\n     - 待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）\n     - 抽取规则：nextReviewDate在<=今天，level>0\n   - 未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个\n4. 拉取今天的`word_memory_daily_statistics`\n5. 循环背单词（显示假名），并建立/更新每个单词的用户信息\n   - pass_count\n   - fail_count\n   - not_sure_count\n6. 快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量\n   - level\n     - 0: 未背\n     - 1: 已被标记为ok\n     - 2: 在1天后复习\n     - 3: 在2天后复习\n     - 4: 在4天后复习\n     - 5: 在7天后复习\n     - 6: 在15天后复习\n     - 7: 在30天后复习\n   - next_review_date\n7. 将3,4中得到的用户信息和server同步，然后回到2	2015/3/5 16:04:39	2015/3/12 18:47:49	1	
3	现有的console执行逻辑	<h3>Command Part</h3>\n<ul>\n<li><strong>现有逻辑</strong>：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入</li>\n<li><strong>改造方法</strong>：Command的execute返回promise</li>\n</ul>\n<h3>Application Part</h3>\n<ul>\n<li><p><strong>现有逻辑</strong>：</p>\n<ul>\n<li><strong>启动application</strong>：\n<ol>\n<li>console调用start：<code>this.activeApplication = application;application.start(optionStr);</code></li>\n<li>application在start中调用main</li>\n</ol></li>\n<li><strong>进入输入模式/application命令行模式</strong>\n<ul>\n<li><strong>输入模式</strong>：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end</li>\n<li><strong>application命令行模式</strong>：将application的currentHandler置空，之后在console上注册applicationCommands</li>\n</ul></li>\n</ul></li>\n<li><p><strong>改造方法：</strong></p>\n<ul>\n<li>console作为控制主体，application的start和execute返回promise</li>\n</ul></li>\n</ul>\n	### Command Part ###\n- **现有逻辑**：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入\n- **改造方法**：Command的execute返回promise\n\n### Application Part ###\n- **现有逻辑**：\n  - **启动application**：\n     1. console调用start：`this.activeApplication = application;application.start(optionStr);`\n     2. application在start中调用main\n  - **进入输入模式/application命令行模式**\n     - **输入模式**：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end\n     - **application命令行模式**：将application的currentHandler置空，之后在console上注册applicationCommands\n\n- **改造方法：**\n  - console作为控制主体，application的start和execute返回promise	2015/3/6 15:25:45	2015/3/9 10:48:37	1	command part
