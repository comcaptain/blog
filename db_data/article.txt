article_id	title	content	markdown	create_time	update_time	author	thumbnail
1	To do list	<ol>
<li>move my cmd here, and the url is <a href="./cmd">/Pygmalion/cmd</a></li>
</ol>
	1. move my cmd here, and the url is [/Pygmalion/cmd](./cmd)	2015/3/5 15:40:26	2015/3/5 15:40:26	1	move my cmd here, and the url is /Pygmalion/cmd
2	背单词流程	<ol>
<li>login detection，如果没有login，就要先login</li>
<li>选择词库</li>
<li>拉取单词列表（和<code>word_memory_record</code>关联）
<ul>
<li>待复习单词列表，如果不为空，从待复习单词中抽出来20个
<ul>
<li>待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）</li>
<li>抽取规则：nextReviewDate在&lt;=今天，level&gt;0</li>
</ul></li>
<li>未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个</li>
</ul></li>
<li>拉取今天的<code>word_memory_daily_statistics</code></li>
<li>循环背单词（显示假名），并建立/更新每个单词的用户信息
<ul>
<li>pass_count</li>
<li>fail_count</li>
<li>not_sure_count</li>
</ul></li>
<li>快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量
<ul>
<li>level
<ul>
<li>0: 未背</li>
<li>1: 已被标记为ok</li>
<li>2: 在1天后复习</li>
<li>3: 在2天后复习</li>
<li>4: 在4天后复习</li>
<li>5: 在7天后复习</li>
<li>6: 在15天后复习</li>
<li>7: 在30天后复习</li>
</ul></li>
<li>next_review_date</li>
</ul></li>
<li>将3,4中得到的用户信息和server同步，然后回到2</li>
</ol>
	1. login detection，如果没有login，就要先login
2. 选择词库
3. 拉取单词列表（和`word_memory_record`关联）
   - 待复习单词列表，如果不为空，从待复习单词中抽出来20个
     - 待复习列表nextReviewDate的维护：迟延到下下个复习时间的时候降一级，以当前时间为初始时间，计算nextReviewDate（daily batch处理，中午12点执行）
     - 抽取规则：nextReviewDate在<=今天，level>0
   - 未背诵单词列表，如果上面的列表为空，从未背诵的单词中随机抽出20个
4. 拉取今天的`word_memory_daily_statistics`
5. 循环背单词（显示假名），并建立/更新每个单词的用户信息
   - pass_count
   - fail_count
   - not_sure_count
6. 快速循环第二次，并建立/更新每个单词的用户信息，并维护背诵单词的总数量
   - level
     - 0: 未背
     - 1: 已被标记为ok
     - 2: 在1天后复习
     - 3: 在2天后复习
     - 4: 在4天后复习
     - 5: 在7天后复习
     - 6: 在15天后复习
     - 7: 在30天后复习
   - next_review_date
7. 将3,4中得到的用户信息和server同步，然后回到2	2015/3/5 16:04:39	2015/3/12 18:47:49	1	
3	现有的console执行逻辑	<h3>Command Part</h3>
<ul>
<li><strong>现有逻辑</strong>：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入</li>
<li><strong>改造方法</strong>：Command的execute返回promise</li>
</ul>
<h3>Application Part</h3>
<ul>
<li><p><strong>现有逻辑</strong>：</p>
<ul>
<li><strong>启动application</strong>：
<ol>
<li>console调用start：<code>this.activeApplication = application;application.start(optionStr);</code></li>
<li>application在start中调用main</li>
</ol></li>
<li><strong>进入输入模式/application命令行模式</strong>
<ul>
<li><strong>输入模式</strong>：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end</li>
<li><strong>application命令行模式</strong>：将application的currentHandler置空，之后在console上注册applicationCommands</li>
</ul></li>
</ul></li>
<li><p><strong>改造方法：</strong></p>
<ul>
<li>console作为控制主体，application的start和execute返回promise</li>
</ul></li>
</ul>
	### Command Part ###
- **现有逻辑**：Command类中有end(message)方法，命令执行完后手动调用end，在end中会调用console的onExecuteComplete来开启新的输入
- **改造方法**：Command的execute返回promise

### Application Part ###
- **现有逻辑**：
  - **启动application**：
     1. console调用start：`this.activeApplication = application;application.start(optionStr);`
     2. application在start中调用main
  - **进入输入模式/application命令行模式**
     - **输入模式**：在application上设定currentHandler（通过调用next方法），之后调用console.onExecuteComplete，在下一次enter按下后，console会在以下条件下执行applicationcurrentHandler：有application正在运行并且application的currentHandler不为空。currentHandler中会继续调用next或者end
     - **application命令行模式**：将application的currentHandler置空，之后在console上注册applicationCommands

- **改造方法：**
  - console作为控制主体，application的start和execute返回promise	2015/3/6 15:25:45	2015/3/9 10:48:37	1	command part
